
• I opted for a recursive implementation for the sequential version due to it feeling more natural and since it outperforms the recursive version. The time complexity is O(N!) for the sequential version. To cut down on the running time of the algorithm (preventing it from generating permutations of the entire alphabet) I introduced 2 mechanism which would allow me to “speed up” the process.  First, under the assumption that for this problem set I would be aware of the length of the strings used to create the hash, I only brute-forced strings of length N. Second, I made sure the algorithm terminated once a hash was found to avoid generating unnecessary permutations.

• Once I was ready to move on to the parallel design is when I discovered that designing or opting for an algorithm with parallelism in mind during the initial design phase (sequential) is crucial. While I gained some speed up in the parallel version, trying to parallelize recursion proved to be more complex than I had expected. Spent hours researching the subject and found that OMP designed a “task” directive clause for similar problems to aid programmers attempting to parallelize recursive algorithms but that meant redesigning my algorithm to fit the template. After hours trying to fit my algorithm to the template without redesigning it I decided to move on to Pthreads. Given to the amount of control provided to the programmer by Pthreads I was able to come up with a way to parallelize my algorithm. From the observation that one thread would have to generate all permutations for each character in the string e.g.: “ABC”, I designed my algorithm to assign as many threads as were available to the problem. But made sure each thread was tasked with generating all permutations of a given character such as thread 1 would generate permutations for character a from string “ABC…”, thread 2 would work on b from string “ABC.” all up to size of length of hash. My observation was that the time complexity of the algorithm didn’t change; it was still O(N!) but instead of one thread running O(N!), each thread was performing on this time complexity. This led to some noticeable speed up from the sequential version. 

• Ran different test cases, strings size 1-2 characters were cracked in under 30 seconds for both the parallel and sequential version. Characters length 3 were cracked in ~1:40s for the sequential version and under ~40s for the parallel version. Characters between lengths 4-6 were cracked anywhere between 25 minutes to over an hour depending on where the character sequence laid in the alphabet.
